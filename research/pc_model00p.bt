//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: PC Model00p Template
//   Authors: HeyThereCoffeee
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

struct LTString {
    ushort Length;
    char Value[Length];
};

struct LTUV {
    float u,v;
};

// Divide by 64
struct LTCompressedVector {
    short x,y,z;
};

struct LTVector {
    float x,y,z;
};

// Divide by 0x7FFF
struct LTCompressedQuat {
    ushort x,y,z,w;
};

struct LTQuat {
    float x,y,z,w;
};

struct LTMatrix {
    LTQuat m[4];
};

struct Header {
    char Format[4];
    
    if (Format == "LDOM") {
        BigEndian();
    }

    int Version;
    int KeyframeCount;
    int AnimationCount;
    int NodeCount;
    int PieceCount;
    int ChildModelCount; // For some reason this always includes the current model, so it's always +1 more!
    int LODCount;
    int SocketCount;
    int AnimationWeightCount;
    int AnimationHeaderCount; // Use to be AnimationBindingCount...
    int StringDataLength; // Length in bytes of the text section
    int PhysicsWeightCount;
    int PhysicsShapeCount;
    int Unk12;
    int BallAndSocketContraintCount; // Not confirmed
    int StiffSpringConstraintCount;
    int HingeConstraintCount;
    int LimitedHingeConstraintCount;
    int RagdollConstraintCount;
    int WheelConstraintCount;
    int PrismaticConstraintCount;
    int AnimationDataLength;// Maybe Mesh or Animation Data?
    char StringList[StringDataLength];
};

struct AnimationHeaderOld {
    short UnkShort;
    short what;
    char what2;
    int Unk[19];
    int Unk2[9];
    int AnimationDataLength;
    ushort Flags[4];
};
 
struct Node {
    int NameOffset;
    short Index; // Node Index
    char Flag; // Node Flags
    LTVector Location;
    LTQuat Rotation;
    int ChildCount;
};

struct Transform {
    LTVector Position;
    LTCompressedQuat Rotation;
};

struct TransformNoRotation {
    LTVector Position;
};

struct TransformNoPosition {
    LTCompressedQuat Rotation;
};



// Forward
struct AnimationHeader;

struct Animation (int NodeCount, AnimationHeader &animHdr) {
/*
    if (animHdr.Type3 & 0x8000) {
        Transform FirstTransform;//[NodeCount];
    } else {
        TransformNoPosition FirstTransform;
    }


    if (animHdr.Type5 & 0x8000) { 
        Transform Transforms[NodeCount-1];
    } else {
        LTCompressedQuat Transforms[NodeCount-1];
    }
*/


/*
    if (animHdr.Type == 12) {
        TransformNoRotation Transforms[NodeCount];
    }
    else if (animHdr.Type == 16) {
        TransformNoPosition Transforms[NodeCount];
    } else if (animHdr.Type == 40) {
        Transform Transforms[NodeCount];
    }

    if (animHdr.Type2 == 12) {
        TransformNoRotation Transforms2[NodeCount];
    }
    else if (animHdr.Type2 == 16) {
        TransformNoPosition Transforms2[NodeCount];
    } else if (animHdr.Type2 == 40) {
        Transform Transforms2[NodeCount];
    }
*/
    
    // 0xFFFF = no data
    // 0x8000 = data!
    // If 0x8000, then a running count in bytes is OR'd onto 0x8000. 
    // Ex/ First instance is 0x8000, a vector sized to 12 bytes occurs, the next 0x8000 instance will be 0x800C.

/*
It starts off with the total data length, and then 0. Next two things can happen. (For reference: 65535 = 0xFFFF, and 32768 = 0x8000) 

It can be 0xFFFF which means no data/carry over the previous data (RLE), or it can be a value OR'd by 0x8000. If the value is 0x8000 it's OR'd by a running total of bytes. 

So to read in the flags you need to do something like this:
var total = read(2) 
skip(2) // skip the 0 padding

var running_total = 0
var is_data_pos = True
while running_total < total:
  var current_flag = read(2)
  // Data seems to be stored as Pos, Rot, Pos, Rot...
  // So flip the flag
  is_data_pos = !is_data_pos
  
  // Skip this value!
  if current_flag == 0xFFFF:
    continue
  
  // Maybe not needed??
  // Get the amount that's been read so far
  //var read_so_far = current_value - 0x8000

  if is_data_pos:
    running_total += 12
  else:
    running_total += 8 // 4 shorts   

Although the RLE part seems a bit tricky, as it will only create another flag section if the data has changed. So I think I need to also track the total number of frames per this animation to determine which frames have data vs what is carried over.

*/
/*
    // Example is based off 1x1 square 
    if (animHdr.Type3 != 65535) {//& 0x8000 == 0) {
        LTVector Position;
    }
    if (animHdr.Type4 != 65535) {
        LTCompressedQuat Rotation;
    }
    if (animHdr.Type5 != 65535) {
        LTVector Position2;
    }
    if (animHdr.Type6 != 65535) {
        LTCompressedQuat Rotation2;
    }
  */  

};

// This is RLE boo!
// Type1 seems to be the size of the actual animation data, but it's sometimes not?
// There's then a lot of 0xFFFFFFF and some 0x8000!

// Maybe??
// Data length?
// Always ends with 0 section
// 0xFFFF signifies nothing here mate
// 0x8000 signifies repeat
// VALUE | 0x8000 signifies repeating this value
// Anything | 0x8000 eventually adds up to the data length? (Not in all cases)
struct AnimationHeader {
    int Unk;

    ushort Track1;
    ushort Track2;

    // Divide by 2 (without having to take into account 0!)
    local int Track1Count = Track1 >> 1;
    local int Track2Count = Track2 >> 1;

    //ushort Flags[Track1Count + Track2Count + 4000];
};

struct AnimationKeyframe {
    int Time;
    int StringOffset;
};

struct AnimationInfo {
    LTVector Dims;
    float Radius;
    int NameOffset;
    int InterpTime;
    int SchemaIndex;
    int DataPosition;
    int IsCompressed;
    int KeyframeCount;
    AnimationKeyframe Keyframes[KeyframeCount];
};

struct Piece {
    int Unk[18];
    char Unk;
    char TextureIndex;
    char Translucent;
    char CastsShadow;
};

struct Test {
    int Here;
};

struct AnimSchema {
    char Data;
};

struct AnimData {
    char Data;
};

struct ChildModel {
    LTString Name;
};

struct ChildModelHeader {
    int ChildModelCount;
    ChildModel ChildModels[ChildModelCount - 1] <optimize=false>;
};

struct ChildModelHeaderv34 {
    int ChildModelCount;
    // Can't find a v34 model with child models, so this is just a guess!
    ChildModel ChildModels[ChildModelCount] <optimize=false>;
};

struct NodeWeight {
    char Physics;
    // Differences from 1.0/0.0?
    float VelocityGain;
    float HierachyGain;
};

struct PhysicsWeightSet (int Count) {
    int NameOffset;
    NodeWeight NodeWeights[Count];
};

struct PhysicsShape {
    char ShapeIndex;
    LTVector Offset;
    LTQuat Orientation;

    float Cor;
    float Friction;
    
    int CollisionGroup; // Maybe CollisionGroup
    int NodeIndex;

    float Mass;
    float Density; // This can be scaled per shape!
    float Radius;

    // If Orientation isn't 0,0,0,1 then it's not a sphere!
    // Probably a capsule, haven't ran into anyother shapes yet tho.
    if (Orientation.w != 1.0) {
        int Unk1;
        float LengthPt1;
        float Unk2[2];
        float LengthPt2;
        int Unk3;
    }
};

struct PhysicsConstraintData {
    int Type;
    int ShapeIndex;
    int VertCount;
    //int Shape2Index;
    if (Type == 4) { // Ragdoll constraint
        float Data[24];
        float Friction;
    } else if (Type == 3) { // Limited Hinge Constraint
        float Data[18];
        float Friction;
        float Unk1;
        float Unk2;
    }
};

struct PhysicsHeader {
    int VisNode;
    float VisRadius;
    int ShapeCount;
    PhysicsShape Shapes[ShapeCount] <optimize=false>;
    int ConstraintCount;
    PhysicsConstraintData ConstraintData[ConstraintCount] <optimize=false>;
    int WeightSetCount;
    PhysicsWeightSet WeightSets(ShapeCount)[WeightSetCount] <optimize=false>;
};

struct AnimationWeightSet (int NodeCount) {
    // Actually NameOffset
    int NameOffset; 
    int Unk; // ?
    float Weights[NodeCount];
};

struct AnimationWeightSetHeader (int NodeCount) {
    int Count;
    AnimationWeightSet WeightSets(NodeCount)[Count] <optimize=false>;
};

struct LODInfo {
    float LodDistance;
    char TextureIndex;
    char Translucent;
    char CastShadow;
    int PieceCount;
    int PieceIndexes[PieceCount];
};

struct SubLODInfo {
    float LodDistance;
    char TextureIndex;
    char Translucent;
    char CastShadow;
    int Unk1;
};

struct LODGroup {
    int NameOffset;
    int LODCount;
    LODInfo LODInfoData[LODCount] <optimize=false>;
};

struct LODGroupHeader {
    int LODGroupCount;
    LODGroup Groups[LODGroupCount] <optimize=false>;
};

struct Unk2 {
    int Unk3; // LOD Related?
    int PieceCount;
    int Unk5; // LOD Related?
    int Unk6;
    int LODCount;
    if (PieceCount == 0) {
        LTString MeshFile;
    }
};

struct Mesh {
    LTVector Vertex;
    LTVector Normals;
    LTUV UVs;
    LTVector Unk1;
    LTVector Unk4;
    uchar WeightInfo[3];
    uchar Padding;
    uchar NodeIndexes[3];
    uchar Padding2;
};

struct Meshv34 {
    LTVector Vertex;
    LTVector Normals;
    LTUV UVs;
    LTVector Unk1;
    LTVector Unk4;
    uchar Colour[4];
    uchar WeightInfo[3];
    uchar Padding;
    uchar NodeIndexes[3];
    uchar Padding2;
};

struct MeshHeader (int Version) {
    int TextureCount;
    
    // DataLength / 64 = MeshData
    int DataLength;
    // DataCount / 2 = tri-fs count
    int IndexListLength;

    if (Version == 34) {
        Meshv34 MeshData[DataLength/68];
    } else {
        Mesh MeshData[DataLength/64];
        //Meshv34 MeshData[DataLength/68];
    }   

    short IndexList[IndexListLength/2]; // DataCount in bytes
};

struct ContainsGeometry {
    char Flag;
};

struct Socket {
    int NodeIndex;
    int NameOffset;
    LTQuat Rotation;
    LTVector Position;
    float Scale;
};

struct SocketHeader {
    int SocketCount;
    Socket Sockets[SocketCount] <optimize=false>;
};

// Related to Deformers
struct MeshInfo {
    int MeshDataStart;
    int MeshDataCount;
    //int IndexListStart;
    //int IndexListCount;
    int MeshDataSize;
    int IndexListPosition;
    //int MeshDataPosition; // Maybe?
    int Unk;
    int TriangleCount;
    int MaterialIndex;
    int InfluenceCount;
    int Unk;
    char NodeIndexes[InfluenceCount];
};

struct AfterMesh {
    int Unk;
    int ByteDataCount;
    //short ShortData[ShortDataCount / 2];
    uchar ByteList[ByteDataCount];
    // Mesh Info?
    int MeshInfoCount;
    MeshInfo Info[MeshInfoCount] <optimize=false>;
};

Header hdr;

// String database, we need to skip it for now
//FSeek(FTell() + hdr.StringDataLength);

Node Nodes[hdr.NodeCount];
AnimationHeader animHdr;

if (hdr.AnimationDataLength > 0) {
    // CUBE
    AnimSchema skip[16]; // Replace this with the schema length
    // DELTA
    //AnimSchema skip[652]; // delta 652
    // ROPE
    //AnimSchema skip[32];
    // Condemned Default00p
    //AnimSchema skip[8];
    // Prototype
    //AnimSchema skip[1212];
    // Player NewHand
    //AnimSchema skip[272];
} else {
    //AnimSchema skip[4];
    // Condemned, empty is 8?
    AnimSchema skip[8];
}
AnimData skip2[hdr.AnimationDataLength];
//Animation Anim(hdr.NodeCount, animHdr)[hdr.AnimationCount] <optimize=false>;
AnimationInfo animInfo[hdr.AnimationCount] <optimize=false>;

AnimationWeightSetHeader animWeightSetHeader(hdr.NodeCount);

SocketHeader socketHeader;

if (hdr.Version == 34) {
    ChildModelHeaderv34 childModels;
} else {
    ChildModelHeader childModels;
}
ContainsGeometry hasGeometry;
// Geometry related
PhysicsHeader PhysicsInfo;


LODGroupHeader lodGroupHeader;
Unk2 unk2;
MeshHeader meshHeader(hdr.Version);
AfterMesh Debug;
//FSkip(420); // DeltaForce
//MeshHeader meshHeader2;
// LOD info at the bottom, and then mesh data continues per piece